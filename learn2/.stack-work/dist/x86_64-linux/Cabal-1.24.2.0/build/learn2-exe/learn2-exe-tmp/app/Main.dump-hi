
==================== FINAL INTERFACE ====================
2017-07-11 12:23:20.491596 UTC

interface main@main:Main 8002
  interface hash: 0fc2504a3f419ea5570ffbdb28c6b4ae
  ABI hash: faa61fe1732e0b1e69fe2b9fbc147665
  export-list hash: 7f54e26a1216669b17cde1281f55d851
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97487e0c0526252d15bd6afc620a024f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.addVectors
  Main.apply_twise
  Main.bmiTell
  Main.characters
  Main.elem'
  Main.factorial
  Main.filter'
  Main.flip'
  Main.head'
  Main.inc'
  Main.lucki
  Main.main
  Main.max'
  Main.max''
  Main.max4'
  Main.mod'
  Main.repeate'
  Main.replicate'
  Main.reverce'
  Main.sort'
  Main.take'
  Main.tell
  Main.zip'
  Main.zipWith'
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
                      learn2-0.1.0.0@learn2-0.1.0.0-BYJBRM22o4Q4bSuiN4h3Vt
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Typeable 9257e47d10882145c67c5b489965cfb7
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  learn2-0.1.0.0@learn2-0.1.0.0-BYJBRM22o4Q4bSuiN4h3Vt:Lib 66f3392567a3b14b939c355072249093
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
e47f38d056b6b3e367143a2c7bacf44e
  $wrepeate' :: a -> (# a, [a] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>, Inline: [0] -}
84aebb20b1a4d24376d022921716197a
  $wreplicate' :: GHC.Prim.Int# -> a -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ @ a (ww :: GHC.Prim.Int#) (w :: a) ->
                 case ww of ds {
                   DEFAULT
                   -> GHC.Types.:
                        @ a
                        w
                        (let {
                           n :: GHC.Prim.Int# = GHC.Prim.-# ds 1#
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<# 0# n) of wild {
                           GHC.Types.False -> GHC.Types.[] @ a
                           GHC.Types.True
                           -> let {
                                lvl15 :: [a] = GHC.Types.: @ a w (GHC.Types.[] @ a)
                              } in
                              letrec {
                                $wxs :: GHC.Prim.Int# -> [a]
                                  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                = \ (ww1 :: GHC.Prim.Int#) ->
                                  case ww1 of ds1 {
                                    DEFAULT -> GHC.Types.: @ a w ($wxs (GHC.Prim.-# ds1 1#))
                                    1# -> lvl15 }
                              } in
                              $wxs n })
                   0# -> GHC.Types.[] @ a
                   1# -> GHC.Types.: @ a w (GHC.Types.[] @ a) }) -}
48e72664ec065272a511dc996ac15c28
  addVectors ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: (GHC.Types.Int, GHC.Types.Int))
                   (ds1 :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case ds of wild { (,) x1 y1 ->
                 case ds1 of wild1 { (,) x2 y2 ->
                 (GHC.Num.$fNumInt_$c+ x1 x2, GHC.Num.$fNumInt_$c+ y1 y2) } }) -}
98f71a5465ff963f8e914866d143f621
  apply_twise :: t -> (t -> t) -> t
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),C(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ t (x :: t) (f :: t -> t) -> f (f x)) -}
b4e54552e5a0ddb20cfe154cb983904a
  bmiTell :: GHC.Types.Double -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S),1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (bmi :: GHC.Types.Double) ->
                 case bmi of wild { GHC.Types.D# x ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=## x 18.5##) of wild1 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=## x 25.0##) of wild2 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<=## x 30.0##) of wild3 {
                             GHC.Types.False -> Main.bmiTell4 GHC.Types.True -> Main.bmiTell3 }
                        GHC.Types.True -> Main.bmiTell2 }
                   GHC.Types.True -> Main.bmiTell1 } }) -}
4fcbb0e0f1f4757472435797eb6623fa
  bmiTell1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "hudoi"#) -}
4fe734b2f446d54d83544e9e7f167408
  bmiTell2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "normal"#) -}
4fb72fcaf1aab14b31ed1b95f71142ba
  bmiTell3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "tolstyi"#) -}
7a2786d7403b27456f98cc08ca5db69a
  bmiTell4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "wirnyi"#) -}
d7e66b3e5b5a062aaf61a31de0bcda09
  characters :: [GHC.Types.Char] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Types.Char]) ->
                 case ds of wild {
                   [] -> Main.characters4
                   : x ds1
                   -> case ds1 of wild1 {
                        [] -> Main.characters3
                        : y ds2
                        -> case ds2 of wild2 {
                             [] -> Main.characters3
                             : ipv ipv1
                             -> case x of ww { GHC.Types.C# ww1 ->
                                let {
                                  karg :: [GHC.Types.Char]
                                  = GHC.CString.unpackAppendCString#
                                      " is first and "#
                                      (case y of ww2 { GHC.Types.C# ww3 ->
                                       let {
                                         karg1 :: [GHC.Types.Char]
                                         = GHC.CString.unpackAppendCString#
                                             " is the second characters in "#
                                             wild
                                       } in
                                       case ww3 of ds3 {
                                         DEFAULT
                                         -> GHC.Base.++
                                              @ GHC.Types.Char
                                              (GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.shows14
                                                 (GHC.Show.$wshowLitChar ds3 Main.characters2))
                                              karg1
                                         '\''#
                                         -> GHC.Base.++ @ GHC.Types.Char Main.characters1 karg1 } })
                                } in
                                case ww1 of ds3 {
                                  DEFAULT
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       (GHC.Types.:
                                          @ GHC.Types.Char
                                          GHC.Show.shows14
                                          (GHC.Show.$wshowLitChar ds3 Main.characters2))
                                       karg
                                  '\''#
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Main.characters1
                                       karg } } } } }) -}
9734a1d1aa563465ab0aa8c080354efa
  characters1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   GHC.Show.shows13
                   (GHC.Types.[] @ GHC.Types.Char)) -}
bda6425f4e0ff7e9a376ed742a5caed8
  characters2 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows14
                   (GHC.Types.[] @ GHC.Types.Char)) -}
76e78ae614c7879d0bd8b97529cc5f16
  characters3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "String is to short"#) -}
b7160c1dc3af9ee5c98ac0ca831b4413
  characters4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "empty string"#) -}
35a545ac391c8566ca607309c9016d02
  elem' :: GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U><S,1*U> -}
a29097830af32a2c4ff81e4a7140db64
  factorial :: (GHC.Num.Num t, GHC.Classes.Eq t) => t -> t
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,U(A,C(C1(U)),C(C1(U)),A,A,A,C(U))><S(C(C(S))L),U(C(C1(U)),A)><L,U>,
     Unfolding: (\ @ t
                   ($dNum :: GHC.Num.Num t)
                   ($dEq :: GHC.Classes.Eq t)
                   (eta :: t) ->
                 let {
                   lvl15 :: t = GHC.Num.fromInteger @ t $dNum Main.factorial2
                 } in
                 let {
                   lvl16 :: t = GHC.Num.fromInteger @ t $dNum Main.factorial1
                 } in
                 letrec {
                   factorial3 :: t -> t {- Arity: 1, Strictness: <L,U> -}
                   = \ (ds :: t) ->
                     case GHC.Classes.== @ t $dEq ds lvl16 of wild {
                       GHC.Types.False
                       -> GHC.Num.*
                            @ t
                            $dNum
                            ds
                            (factorial3 (GHC.Num.- @ t $dNum ds lvl15))
                       GHC.Types.True -> lvl15 }
                 } in
                 factorial3 eta) -}
a230016339452874f6611b08023f60aa
  factorial1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
87c3e7758221475791ffbda5ce3bce34
  factorial2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
9f659c1de3e933feb9a73dcf7e7bc6db
  filter' :: (a -> GHC.Types.Bool) -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
a0e835eeca6df784fcb10a790427be85
  flip' :: (a -> b -> c) -> b -> a -> c
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a @ b @ c (f :: a -> b -> c) (x :: b) (y :: a) -> f y x) -}
7abc203f748fc7ac283530e04fac82e7
  head' :: [a] -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 case xs of wild { [] -> Main.head'1 @ a : x ds -> x }) -}
53115e7bbdb287e98285bd7ea7de996f
  head'1 :: a
  {- Strictness: x -}
e685330edbb8ea6b62a81ae87f68eb1b
  inc' :: GHC.Num.Num a => a -> a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
     Unfolding: (\ @ a ($dNum :: GHC.Num.Num a) ->
                 let {
                   ds :: a = GHC.Num.fromInteger @ a $dNum Main.factorial2
                 } in
                 \ (ds1 :: a) -> GHC.Num.+ @ a $dNum ds1 ds) -}
9692ae7690e3102e6738a1a2b8935d7f
  lucki :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Int) ->
                 case ds of wild { GHC.Types.I# ds1 ->
                 case ds1 of ds2 { DEFAULT -> Main.lucki2 7# -> Main.lucki1 } }) -}
165bc2f2ebfaa85e239ce3c4fdb18360
  lucki1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "!Lucki number! :)"#) -}
c349eeb3405bd1f45dd3be2b2077a599
  lucki2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "No, sorry"#) -}
0c9b2c2956c6073408675c6a312767bb
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
a601c3b4b1454e0e36d236920e6cfac8
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (eta :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   Main.main2
                   GHC.Types.True
                   eta) -}
d7744f6630720eeada3c9f21eb8ff4a2
  main2 :: GHC.Base.String
  {- Unfolding: (GHC.Show.$fShowInteger_$cshowList
                   Main.main3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cf82cfd5620b538d7852454ca8d68dd1
  main3 :: [GHC.Integer.Type.Integer]
  {- Unfolding: (Main.main_go Main.factorial2) -}
ed17ffffc235f99fe4637c2b9a46a3c3
  main4 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
9d931c8ee02c9223474add66f64e3bdb
  main_go :: GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
  {- Arity: 1, Strictness: <S,U> -}
0534243fa4b9b2d4a7033c7e121fd5d7
  max' :: GHC.Classes.Ord a => [a] -> a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(C1(U)),A)><S,1*U> -}
b6c743c4c74500d92259f022317a2005
  max'' :: GHC.Classes.Ord a => [a] -> a
  {- Arity: 2,
     Strictness: <S(LLLLC(C(S))LLL),U(A,A,A,A,1*C1(C1(U)),A,C(C1(U)),A)><S,1*U>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) (ds :: [a]) ->
                 case ds of wild {
                   [] -> Main.max''1 @ a
                   : x ds1
                   -> case ds1 of wild1 {
                        [] -> Main.max''1 @ a
                        : y ds2
                        -> case ds2 of wild2 {
                             []
                             -> case GHC.Classes.> @ a $dOrd x y of wild3 {
                                  GHC.Types.False -> y GHC.Types.True -> x }
                             : ipv ipv1
                             -> case GHC.Classes.> @ a $dOrd x y of wild3 {
                                  GHC.Types.False -> Main.max' @ a $dOrd wild1
                                  GHC.Types.True
                                  -> Main.max' @ a $dOrd (GHC.Types.: @ a x wild2) } } } }) -}
f69cec024b81ac92f3e16789ba43e6ad
  max''1 :: a
  {- Strictness: x -}
2b1122e716d760d4d6d00703cbaeb28c
  max4' :: (GHC.Num.Num a, GHC.Classes.Ord a) => a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><S(LLLLLLC(S)L),1*U(A,A,A,A,A,A,1*C1(U),A)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) ($dOrd :: GHC.Classes.Ord a) ->
                 GHC.Classes.max
                   @ a
                   $dOrd
                   (GHC.Num.fromInteger @ a $dNum Main.max4'1)) -}
c118a5528943754a71b066391aa23eab
  max4'1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (4) -}
da3fc8b9d3e612f6d3e5ebd06a189a32
  mod' :: (GHC.Num.Num a, GHC.Classes.Ord a) => a -> a -> a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U> -}
2b2adcf353be33371bf49e3dfdf7cc6a
  repeate' :: a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: a) ->
                 case Main.$wrepeate' @ a w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ a ww1 ww2 }) -}
a031db3ea5e76b5aca8f10419c45ea7a
  replicate' :: GHC.Types.Int -> a -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: a) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$wreplicate' @ a ww1 w1 }) -}
32d534ec86269bd5ead37e6d29336454
  reverce' :: [a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
055e7ef6072abf3d15977f9c170f9cf3
  sort' :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,C(C1(U)),A,A)><S,1*U> -}
485b451c1ee901c861e2ef90d9e807b1
  take' :: (GHC.Num.Num i, GHC.Classes.Ord i) => i -> [a] -> [a]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,C(U))><S(LLLC(C(S))LLLL),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)><L,U><L,1*U> -}
a5f8fad631f745a9c1e7a12e46c3f90a
  tell :: GHC.Show.Show a => [a] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(A,C(U),1*C1(C1(U)))><S,1*U>,
     Unfolding: (\ @ a ($dShow :: GHC.Show.Show a) (ds :: [a]) ->
                 case ds of wild {
                   [] -> Main.tell3
                   : x ds1
                   -> case ds1 of wild1 {
                        [] -> Main.tell2
                        : y ds2
                        -> case ds2 of wild2 {
                             [] -> Main.tell1
                             : ipv ipv1
                             -> GHC.CString.unpackAppendCString#
                                  "many elems"#
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (GHC.Show.show @ a $dShow x)
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (GHC.Show.show @ a $dShow y)
                                        (GHC.Show.showList
                                           @ a
                                           $dShow
                                           wild2
                                           (GHC.Types.[] @ GHC.Types.Char)))) } } }) -}
dbaa8889e3933103afe41cea819ba34b
  tell1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Only 2 elems"#) -}
70b1e62dae08bfc7d79fb89445ec0713
  tell2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Only 1 elem"#) -}
a85b6cdcd1a2339c1495c295de1d0375
  tell3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "empty list"#) -}
500340111f7aa89bf2f3fd50497fb0e0
  zip' :: [a] -> [b] -> [(a, b)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
027e372abe66d03dd978eeebed0fe4ac
  zipWith' :: (t -> t -> t) -> [t] -> [t] -> [t]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><S,1*U><L,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

